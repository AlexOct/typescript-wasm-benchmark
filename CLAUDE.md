# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a **TypeScript vs WebAssembly performance comparison tool** that benchmarks TypeScript and C++ (compiled to WASM) implementations of algorithms operating on large Uint32Array datasets. The project demonstrates when WASM provides performance benefits over pure TypeScript.

**Tech Stack**: Vite + TypeScript + Emscripten + WASM + pnpm

## Build Commands

### Development
```bash
# Start dev server (requires WASM to be built first)
pnpm run dev

# Build WASM module from C++ (MUST run before dev/build)
pnpm run build:wasm

# Full production build (builds WASM + TypeScript)
pnpm run build

# Preview production build
pnpm run preview
```

### WASM Compilation Requirements
- Emscripten SDK must be installed (default path: `E:\wasmEm\emsdk` on Windows)
- Set `EMSDK` environment variable if using custom path
- [build-wasm.js](build-wasm.js) auto-detects Windows/Unix and activates emsdk environment

## Core Architecture

### Three-Layer Implementation Pattern

Each algorithm is implemented in **three separate locations**:

1. **C++ Implementation** ([src/cpp/array_processor.cpp](src/cpp/array_processor.cpp))
   - Raw C++ with `EMSCRIPTEN_KEEPALIVE` exports
   - Optimized for performance with `-O3` compilation
   - Uses `uint32_t*` pointers for array operations

2. **TypeScript Implementation** ([src/ts-algorithms.ts](src/ts-algorithms.ts))
   - Functionally equivalent TypeScript versions
   - Uses Uint32Array for type consistency
   - Must match C++ behavior exactly for fair comparison

3. **WASM Wrapper Layer** ([src/wasm-loader.ts](src/wasm-loader.ts))
   - Manages WASM memory allocation/deallocation
   - Marshals Uint32Array ↔ WASM memory
   - Uses `ccall()` to invoke C++ functions
   - **Critical**: Always free memory in finally blocks

### Memory Management Pattern

```typescript
// ALWAYS follow this pattern for WASM calls
const ptr = allocateArray(arr);
try {
  const result = module.ccall('funcName', 'number', ['number', 'number'], [ptr, arr.length]);
  return result;
} finally {
  freeArray(ptr); // MUST free to prevent memory leaks
}
```

### Benchmark Framework ([src/benchmark.ts](src/benchmark.ts))

- **Warmup Phase**: 2 iterations before actual testing (JIT optimization)
- **Statistics**: Calculates avg, min, max, median, speedup ratio
- **Test Configuration**: Array size (100K-10M), iterations (3/5/10)
- Each test definition requires: `name`, `nameChinese`, `prepare()`, `tsFunc()`, `wasmFunc()`

## Adding New Algorithms

To add a new performance test, modify **4 files** in order:

1. **[src/cpp/array_processor.cpp](src/cpp/array_processor.cpp:1)** - Add C++ implementation with `EMSCRIPTEN_KEEPALIVE`
2. **[src/ts-algorithms.ts](src/ts-algorithms.ts:1)** - Add equivalent TypeScript implementation
3. **[src/wasm-loader.ts](src/wasm-loader.ts:1)** - Add WASM wrapper in `wasmAlgorithms` object
4. **[src/benchmark.ts](src/benchmark.ts:1)** - Add test definition to `benchmarkTests` array
5. **Rebuild WASM**: Run `pnpm run build:wasm`

See [README.md](README.md) "添加新算法" section for code examples.

## Important File Relationships

- [index.html](index.html) → imports [src/main.ts](src/main.ts) as entry point
- [src/main.ts](src/main.ts) → initializes WASM, handles UI, orchestrates benchmarks
- [src/wasm-loader.ts](src/wasm-loader.ts) → dynamically imports `/array_processor.js` from [public/](public/)
- [public/array_processor.{js,wasm}](public/) → generated by `pnpm run build:wasm` (not in git)

## Emscripten Compilation Details

Command (executed by [build-wasm.js](build-wasm.js)):
```bash
emcc src/cpp/array_processor.cpp -o public/array_processor.js \
  -s WASM=1 \
  -s EXPORTED_RUNTIME_METHODS=['ccall','cwrap','_malloc','_free'] \
  -s ALLOW_MEMORY_GROWTH=1 \
  -s INITIAL_MEMORY=33554432 \      # 32MB
  -s MAXIMUM_MEMORY=2147483648 \    # 2GB
  -s MODULARIZE=1 \
  -s EXPORT_NAME="createWasmModule" \
  -O3 --no-entry
```

**Key Options**:
- `MODULARIZE=1` + `EXPORT_NAME`: Enables `import createWasmModule()` pattern
- `ALLOW_MEMORY_GROWTH`: Required for large arrays (10M elements)
- `-O3`: Maximum optimization (critical for fair benchmarks)
- `--no-entry`: No main() function required

## VSCode C++ Configuration

- [.vscode/c_cpp_properties.json](.vscode/c_cpp_properties.json) - Emscripten include paths
- [.vscode/settings.json](.vscode/settings.json) - C++ IntelliSense settings
- **Important**: Update `includePath` if Emscripten SDK is at custom location
- Defines `__EMSCRIPTEN__` macro for proper syntax highlighting

## Testing Workflow

1. Warmup phase (2 iterations) - discarded
2. Test phase (3/5/10 iterations) - timed with `performance.now()`
3. Statistical analysis (avg/min/max/median)
4. Calculate speedup ratio: `tsAvg / wasmAvg`
5. UI renders results with performance bars

## Common Pitfalls

1. **Forgetting to build WASM**: Always run `build:wasm` before `dev`
2. **Memory leaks**: Missing `freeArray()` in WASM wrappers
3. **Inconsistent implementations**: TS and C++ must behave identically
4. **Platform paths**: [build-wasm.js](build-wasm.js) handles cross-platform, but Emscripten path may need adjustment
5. **C++ IntelliSense errors**: Update [.vscode/c_cpp_properties.json](.vscode/c_cpp_properties.json) if Emscripten moved

## Performance Considerations

- Large arrays (>1M elements) show bigger WASM advantages
- Simple operations (sum, find) may have overhead from WASM marshaling
- Complex operations (sort, variance) benefit most from WASM
- Warmup iterations critical for fair JIT comparison

## Project Goals

- Educational demonstration of WASM performance characteristics
- Fair comparison framework (identical algorithms, proper warmup)
- Extensible design for adding new algorithms
- Production-ready UI with statistical rigor
